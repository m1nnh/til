## :star: Dynamic Programming (Reference : 이것이 코딩테스트다.)

### 1. 다이나믹 프로그래밍 (Dynamic Programming)
- 중복되는 연산을 줄이자.
- 컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다. 그래서 우리는 연산 속도와 메모리 공간을 최대한 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.
- 대표적인 방법으로는 다이나믹 프로그래밍 기법으로 동적 계획법이라고 표현하기도 한다.

### :computer: Fibonachi Code

```
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)


print(fibo(4))
```

### :computer: Fibonachi Code

```
def fibo(x):
    if x == 1 or x == 2:
        return 1
    if array[x] != 0:
        return array[x]
    array[x] = fibo(x - 1) + fibo(x - 2)
    return array[x]


array = [0] * 100
print(fibo(99))
```

- 위 두개 코드는 피보나치 함수를 구현한 것이다. 다만 다른 점은 두 번째는 메모제이션 기법을 활용해 구현한 방법이다. **한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법**을 의미한다. 메모제이션 값을 저장하는 방법이므로 **캐싱**이라고도 한다.
- 정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
- 물론 재귀 함수를 사용하면 **컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생 할 수 있다. 따라서 재귀 함수 대신에 반복문을 사용하여 오버헤드를 줄일 수 있다**.

### :computer: Call Function Code (UpDown)

```
d = [0] * 100


def pibo(x):
    print('f(' + str(x) + ')', end=' ')
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = pibo(x - 1) + pibo(x - 2)
    return d[x]


pibo(6)
```

### Result

```
f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4) 
```

- 이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운 방식** 이라고 말한다.
- 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **보텀업 방식**이라고 말한다.

### :computer: Fibonachi Repeat Code (BottomUp)

```
array = [0] * 100

array[1] = 1
array[2] = 1
n = 99

for i in range(3, n + 1):
    array[i] = array[i - 1] + array[i - 2]
print(array[n])
```

- **탑다운** (메모이제이션) 방식은 '하향식'이라고도 하며, **보텀업** 방식은 '상향식'이라고도 한다. 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
- 보텀업 방식에서 사용되는 결과 저장용 리스트는 **DP 테이블**이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
- 다이나믹 프로그래밍과 메모이제이션의 개념을 혼용해서 사용하는 경우도 있는데, 엄밀히 말하면 메모이제이션은 **이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미**하므로, 다이나믹 프로그래밍과는 별도의 개념이다.
- 코딩 테스트에서의 다이나믹 프로그래밍 문제는 대체로 간단한 형태로 출제되므로, 이 책에서 다루는 문제 정도만 바르게 습득해도 코딩 테스트에서 다이나믹 프로그래밍 문제를 풀기에는 큰 어려움이 없을 것이다.
- 실제로 앞에서 구현한 재귀적인 피보나치 수열의 소스코드에서 오천 번째 이상의 큰 피보나치 수를 구하도록 하면 **recursion depth**와 관련된 오류가 발생할 수 있다. 이 경우 sys 라이브러리에 포함되어 있는 **setrecursionlimit** 함수를 호출하여 재귀 제한을 완화할 수 있다는 점 정도만 기억하자.

### :speech_balloon: 1로 만들기
- 정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.

    a : X가 5로 나누어 떨어지면, 5로 나눈다.

    b : X가 3으로 나누어 떨어지면, 3으로 나눈다.

    c : X가 2로 나누어 떨어지면, 2로 나눈다

    d : X에서 1을 뺀다.


- 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

- 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
  
    1. 26 - 1 = 25 (d)
  
    2. 25 / 5 = 5 (a)
  
    3. 5 / 5 = 1 (a)

### :computer: Code

```
X = int(input())
array = [0] * 30001

for i in range(2, X + 1):
    array[i] = array[i - 1] + 1

    if i % 2 == 0:
        array[i] = min(array[i], array[i // 2] + 1)
    if i % 3 == 0:
        array[i] = min(array[i], array[i // 3] + 1)
    if i % 5 == 0:
        array[i] = min(array[i], array[i // 5] + 1)
print(array[X])
```

### :pencil2: 문제 해설
- 점화식 끝에 +1을 해주는 이유는 함수의 호출 횟수를 구해야 하기 때문이다 

### :speech_balloon: 개미 전사
- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다.
메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다.
각 식량 창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량 창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 
이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량차고가 공격받으면 바로 알아챌 수 있다.
따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.

### :computer: Code

```
N = int(input())
K = list(map(int, input().split()))

A = [0] * 100
A[0] = K[0]
A[1] = max(K[0], K[1])
for i in range(2, N):
    A[i] = max(A[i - 1], A[i - 2] + K[i])
print(A[N - 1])
```

### :pencil2: 문제 해설
- 이 문제는 2가지 경우에 대해서만 확인하면 된다.
    - (i-1)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 없다.
    - (i-2)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 있다.

### :speech_balloon: 바닥 공사
- 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다.
태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해 채우고자 한다.
이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2 x 3 크기의 바닥을 채우는 경우의 수는 5가지이다.
### :computer: Code

```
N = int(input())
D = [0] * 1001
D[1] = 1
D[2] = 3

for i in range(3, N + 1):
    D[i] = (D[i - 1] + 2 * D[i - 2]) % 796796
print(D[N])
```

### :pencil2: 문제 해설
- 왼쪽부터 i - 1 까지 길이가 덮개로 이미 채워져 있으면 2 x 1의 덮개를 채우는 하나의 경우밖에 존재하지 않는다.
- 왼쪽부터 i - 2 까지 길이가 덮개로 이미 채워져 있으면 1 x 2 덮개 2개를 넣는 경우, 혹은 2 x 2의 덮개 하나를 넣는 경우로 2가지 경우가 존재한다.
- 따라서 점화식을 써서 해결하면 된다.

### :speech_balloon: 효율적인 화폐 구성
- N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.
이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.
예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원 5개를 사용하는 것이 가장 최소한의 화폐 개수이다.

### :computer: Code

```
N, M = map(int, input().split())
array = []
D = [10001] * (M + 1)
for i in range(N):
    array.append(int(input()))
D[0] = 0
for i in range(N):
    for j in range(array[i], M + 1):
        if D[j - array[i]] != 10001:
            D[j] = min(D[j], D[j - array[i]] + 1)
if D[M] == 10001:
    print(-1)
else:
    print(D[M])
```

### :pencil2: 문제 해설
- 제가 설명하기엔 어려운 문제이다... 책 참고해주세요..