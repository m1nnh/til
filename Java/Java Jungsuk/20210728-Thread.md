## 쓰레드

### 프로세스와 쓰레드

프로세스란 간단히 말해서 '실행 중인 프로그램'이다. 프로그램을 실행하면 OS로부터 실행에 필요한 메모리를 할당받아 프로세스가 된다. 프로세스는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 쓰레드이다.

그래서 <span style = "background-color:#FAF4C0">모든 프로세스는 최소한 하나 이상의 쓰레드가 존재</span>하며, 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스'라고 한다.

#### 멀티태스킹과 멀티쓰레딩

현재 우리가 사용하고 있는 윈도우나 유닉스를 포함한 대부분의 OS는 멀티태스킹을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다. 이와 마찬가지로 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것이다. CPU의 코어가 한 번에 하나의 작업만 수행할 수 있으므로, 실제로 동시에 처리되는 작업의 개수는 코어의 개수와 일치한다.

#### 멀티쓰레딩의 장점

- CPU의 사용률을 향상시킨다.
- 자원을 보다 효율적으로 사용할 수 있다.
- 사용자에 대한 응답성이 향상된다.
- 작업이 분리되어 코드가 간결해진다.

메신저로 채팅하면서 파일을 다운로드 받거나 음성대화를 나눌 수 있는 것이 가능한 이유가 바로 멀티쓰레드로 작성되어 있기 때문이다. 만일 싱글쓰레드로 작성되어 있다면 파일을 다운로드 받는 동안에는 다른 일을 전혀 할 수 없을 것이다.

### 쓰레드의 구현과 실행

쓰레드를 구현하는 방법은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법, 모두 두 가지가 있다. 어느 쪽을 선택해도 별 차이는 없지만 Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다. <span style = "background-color:#FAF4C0">Runnable 인터페이스를 구현하는 방법은 재사용성이 높고 코드의 일관성을 유지할 수 있기 때문에 보다 객체지향적인 방법</span>이다.

```
1. Thread 클래스를 상속

class MyThread extends Thread {
    public void run() { // Thread 클래스의 run()을 오버라이딩
        ... 
    }
}
```

```
2. Runnable 인터페이스를 구현

class MyThread implements Runnable {
    public void run() { // Runnable 인터페이스의 run()을 구현
        ...
    }
}
```

Thread 클래스를 상속받으면, 자손 클래스에서 조상인 Thread 클래스의 메서드를 직접 호출할 수 있지만, Runnable을 구현하면 Thread 클래스의 static 메서드인 currentThread()를 호출하여 쓰레드에 대한 참조를 얻어 와야만 호출이 가능하다.

#### 쓰레드의 실행

쓰레드를 생성했다고 해서 자동으로 실행되는 것은 아니다. start()를 호출해야만 쓰레드가 실행된다.

```
threadName1.start(); // 쓰레드 1을 실행
threadName2.start(); // 쓰레드 2를 실행
```

start()가 호출되었다고 해서 바로 실행되는 것이 아니라, 일단 실행대기 상태에 있다가 <span style = "background-color:#FAF4C0">자신의 차례가 되어야 실행된다.</span> anffhs 실행대기 중인 쓰레드가 하나도 없으면 곧바로 실행상태가 된다. 또한, 한 번 <span style = "background-color:#FAF4C0">실행이 종료된 쓰레드는 다시 실행할 수 없다.</span> 즉, 하나의 쓰레드에 대해 start()가 한 번만 호출될 수 있다는 뜻이다. 그래서 만일 한 번 더 수행해야 한다면 새로운 쓰레드를 만들어 start()를 호출해야한다.

```
threadName1.start();
threadName1 = new Thread();
threadName1.start();
```

### start()와 run()

main 메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메서드를 호출하는 것일 뿐이다. 반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음에 run()을 호출해서, 생성된 호출스택에 run()이 첫 번째로 올라가게 한다. 모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기 때문에, 새로운 쓰레드를 생성하고 실행시킬 때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다.

<center><img src = "https://user-images.githubusercontent.com/78870076/127261975-e112e13a-5cea-4628-8203-fd3a6dfe9874.png"></center>

호출스택에서는 가장 위에 있는 메서드가 현재 실행중인 메서드이고 나머지 메서드들은 대기상태에 있다는 것을 기억하고 있을 것이다. 그러나 쓰레드가 둘 이상일 때는 호출스택의 최상위에 있는 메서드일지라도 대기상태에 있을 수 있다.

스케줄러는 실행 대기중인 쓰레드들의 우선순위를 고려하여 실행 순서와 실행 시간을 결정하고, 각 쓰레드들은 작성된 스케줄에 따라 자신의 순서가 되면 지정된 시간동안 작업을 수행한다. 이때 주어진 시간동안 작업을 마치지 못한 쓰레드는 다시 자신의 차례가 돌아올 때까지 대기상태로 있게 되며, 작업을 마친 쓰레드, 즉 run()의 수행이 종료된 쓰레드는 호출스택이 모두 비워지면서 이 쓰레드가 사용하던 호츨스택은 사라진다.

### 싱글쓰레드와 멀티쓰레드

두 개의 작업을 하나의 쓰레드로 처리하는 경우와 두 개의 쓰레드로 처리하는 경우를 가정해보자. 하나의 쓰레드로 두 작업을 처리하는 경우는 한 작업을 마친 후에 다른 작업을 시작하지만, 두 개의 쓰레드로 작업 하는 경우에는 짧은 시간동안 2개의 쓰레드가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는 것과 같이 느끼게한다.

<center><img src = "https://user-images.githubusercontent.com/78870076/127262509-c4e7e3dc-3218-461b-894f-5df2e7654464.png"></center>

### 쓰레드의 우선순위

쓰레드는 우선순위(Priority)라는 속성(멤버변수)을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다. 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다. 예를 들어 파일 전송 기능이 있는 메신저의 경우, 파일 다운로드를 처리하는 쓰레드보다 채팅 내용을 전송하는 쓰레드의 우선 순위가 더 높아야 사용자가 채팅하는데 불편함이 없을 것이다.

```
void setPriority(int newPriority)
int getPriority()

public static final int MAX_PRIORITY = 10
public static final int MIN_PRIORITY = 1
public static final int NORM_PRIORITY = 5

threadName1.setPriority(MAX_PRIOORTY) // 10
threadName.getPriority() // 10
```

### 데몬 쓰레드

데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다. 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료되는데, 그 이유는 데몬 쓰레드는 일반 쓰레드의 보조역할을 수행하므로 일반 쓰레드가 모두 종료되고 나면 데몬 쓰레드의 존재의 의미가 없기 때문이다. 데몬 쓰레드의 예로는 <span style = "background-color:#FAF4C0">가비지 컬렉터, 워드프로세서의 자동저장, 화면자동갱신</span> 등이 있다.

데몬 쓰레드는 무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다. 다만 쓰레드를 생성한 다음 실행하기 전에 setDaemon(true)를 호출해야한다. 그리고 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다는 점도 알아둬야한다.

```
boolean isDaemon() // 쓰레드가 데몬 쓰레드인지 확인
void setDaemon(boolean on) // 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 변경한다.
```

```
class MyThread implements Runnable {
    static boolean autoSave = false;
    
    public static void main(String[] args) {
        Thread t = new Thread(new MyThread());
        t.setDaemon(true); // 이 부분이 없으면 종료되지 않는다.
        t.start();

        for (int i = 1; i <= 10; i++) {
            try {
                thread.sleep(1000);
            } catch(InterruptedException e) {

            }

            System.out.println(i);

            if (i == 5)
                autoSave = true
        }

        System.out.println("프로그램 종료");
    }

    public void run() {
        while (true) {
            try {
                Thread.sleep(3 * 1000); // 3초마다
            } catch (InterruptedException e) {

            } 

            if (autoSave) {
                autoSave();
            }
        }
    }

    public void autoSave() {
        System.out.println("작업파일이 자동저장 되었습니다.");
    }
}
```

#### 실행결과

```
1 \ 2 \ 3 \ 4 \ 5 \ 6
작업파일이 자동저장 되었습니다.
7 \ 8 
작업파일이 자동저장 되었습니다.
9 \ 10
프로그램 종료
```

3초마다 변수 autoSave의 값을 확인해서 그 값이 true이면 autoSave()를 호출하는 일을 무한히 반복하도록 쓰레드를 작성하였다. 만일 이 쓰레드를 데몬 쓰레드로 설정하지 않았다면, 이 프로그램은 강제종료하지 않는 한 영원히 종료되지 않을 것이다.

### 쓰레드의 실행제어

쓰레드 프로그래밍이 어려운 이유는 <span style = "background-color:#FAF4C0">동기화와 스케줄링</span> 때문이다. 효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교한 스케줄링을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야 한다.

#### sleep(long millis)

sleep()은 지정된 시간동안 쓰레드를 멈추게 한다.

```
static void sleep(long millis)
static void sleep(long millis, int nanos)
```

sleep()에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나 interrupt()가 호출되면, 잠에서 깨어나 실행대기 상태가 된다. 그래서 sleep()을 호출할 때는 항상 try-catch문으로 예외를 처리해줘야 한다. 

```
threadName1.start();
threadName2.start();

try {
    threadName1.sleep(2000);
} catch(InterruptedException e) {

}
```

쓰레드 1과 2에 대해 start()를 호출하자마자 1을 sleep()하여 쓰레드 1이 2초 동안 작업을 멈추고 일시정지 상태에 있도록 하였으니 쓰레드 1이 가장 늦게 종료되어야 하는데 결과는 가장 먼저 종료되었다. 그 이유는 sleep()은 항상 현재 실행 중인 쓰레드에 대해 작동하기 때문에 실제로 1을 재웠어도, 실제로 영향을 받는 것은 main 메서드를 실행하는 main 쓰레드이다. 그래서 sleep()은 static으로 선언되어 있으며 참조변수를 이용해서 호출하기 보다는 Thread.sleep(2000);과 같이 해야한다.

#### interrupt()와 interrupted()

진행 중인 쓰레드의 작업이 끝나기 전에 취소 시켜야할 때가 있다. interrupt()는 쓰레드에게 작업을 멈추라고 요청한다. 단지 멈추라고 요청만 하는 것일 뿐 쓰레드를 강제로 종료시키지는 못한다.

#### suspend(), resume(), stop()

suspend()는 sleep()처럼 쓰레드를 멈추게 한다. suspend()에 의해 정지된 쓰레드는 resume()을 호출해야 다시 실행대기 상태가 된다. stop()은 호출되는 즉시 쓰레드가 종료된다. 이 세개는 쓰레드의 실행을 제어하는 가장 손쉬운 방법이지만, suspend()와 stop()이 교착상태를 일으키기 쉽게 작성 되어있으므로 사용이 권장되지는 않는다.

### 쓰레드 동기화

멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게된다. 작업의 영향을 주지 않기 위해 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 그래서 도입된 개념이 바로 <span style = "background-color:#FAF4C0">임계 영역과 락</span>이다.

공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고, 공유 데이터가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 한다. 그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다. 이처럼 <span style = "background-color:#FAF4C0">한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화</span>라고 한다.

#### synchronized를 이용한 동기화

먼저 가장 간단한 동기화 방법인 synchronized 키워드를 이용한 동기화에 대해 알아보자. 이 키워드는 임계 영역을 설정하는데 사용된다.

```
1. 메서드 전체를 임계 영역으로 지정

public synchronized void calcSum() {
    ...
}

2. 특정한 영역을 임계 영역으로 지정

synchronized(객체의 참조변수) {
    ...
}
```

첫 번째 방법은 메서드 앞에 키워드를 붙여 메서드 전체가 임계 영역으로 설정된다. 두 번째 방법은 메서드 내의 코드 일부를 블럭으로 감싸고 블럭 앞에 키워드를 붙이는 것인데, 이때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 임계 영역은 멀티 쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메서드 전체에 락을 거는 것보다 임계 영역을 최소화해서 보다 효율적인 프로그램이 되도록 노력해야 한다.

#### wait()과 notify()

synchronized로 동기화해서 공유 데이터를 보호하는 것 까지는 좋은데, 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것도 중요하다. 만일 계좌에 출금할 돈이 부족해서 한 쓰레드가 락을 보유한 채로 돈이 입금될 때까지 오랜 시간을 보낸다면, 다른 쓰레드들은 모두 해당 객체의 락을 기다리느라 다른 작업들도 원할히 진행되지 않을 것이다. 이러한 상황을 개선하기 위해 고안된 것이 바로 wait()과 notify()이다. 동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 wait()을 호출하여 쓰레드가 락을 반납하고 기다리게 한다.

```
void wait()
void wait(long timeout)
void notify()
void notifyAll()
```

wait()은 notify() 또는 notifyAll()이 호출될 때까지 기다리지만, 매개변수가 있는 wait()은 지정된 시간동안만 기다린다. 즉, 지정된 시간이 지난 후에 자동적으로 notify()가 호출되는 것과 같다.