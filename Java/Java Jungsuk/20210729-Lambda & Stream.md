## 람다와 스트림

### 람다식

람다식은 간단히 말해서 메서드를 하나의 '식'으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수'이라고도 한다.

```
int[] arr = new int[5];
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + 1);
```

위에 람다식을 메서드로 표현하면 다음과 같다.

```
int method() {
    return (int)(Math.random() * 5) + 1;
}
```

위의 메서드보다 람다식이 간결하면서도 이해하기 쉽다. 게다가 모든 메서드는 클래스에 포함되어야 하므로 클래스도 새로 만들어야 하고, 객체도 생성해야만 비로소 이 메서드를 호출할 수 있다. 그러나 람다식은 이 모든 과정없이 오직 람다식 자체만으로도 이 메서드의 역할을 대신할 수 있다.

람다식은 '익명 함수'답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 '->'를 추가한다.

```
반환타입 메서드이름 (매개변수 선언) {
    ...
}

(매개변수 선언) -> {...}
```

예를 들어 두 값 중에서 큰 값을 반환하는 메서드 max를 람다식으로 변환하면 다음과 같다.

```
int max(int a, int b) {
    return a > b ? a : b;
}

(int a, int b) -> {return a > b ? a : b;}
```

반환값이 있는 메서드의 경우, return문 대신 '식'으로 대신 할 수 있다. 식의 연산결과가 자동적으로 반환값이 된다. 이때는 문장이 아닌 식이므로 끝에 세미콜론을 붙이지 않는다.

```
(int a, int b) -> a > b ? a : b
```

또한 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다. 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.

```
(a, b) -> a > b ? a : b
```

마찬가지로 괄호 {} 안에 문장이 하나일 때는 괄호를 생략할 수 있다. 이 때 문장의 끝에 세미콜론을 붙이지 않아야 한다는 것에 주의!

### 함수형 인터페이스

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데, <span style = "background-color:#FAF4C0">람다식은 어떤 클래스에 포함되어야 할까?</span> 람다식은 익명 클래스의 객체와 동등하다.

```
(int a, int b) -> a > b ? a : b

// 위에 람다식과 아래 익명 클래스의 객체 내부 메서드와 같다.

new Object() {
    int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

위에 익명 클래스 내부의 max 메서드명은 임의로 붙인 것이지 의미는 없다. 그러면, 익명의 객체의 메서드를 어떻게 호출할 것인가? 참조 변수가 있어야 객체의 메서드를 호출 할 수 있으니까 일단 이 익명 객체의 주소를 f라는 참조 변수에 저장해본다.

```
타입 f = (int a, int b) -> a > b ? a : b;
```

그러면 참조변수 f의 타입은 어떤 것이어야 할까? 참조형이니까 클래스 또는 인터페이스가 가능하다. 그리고 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다. 그래야만 참조변수로 익명 객체의 메서드를 호출할 수 있기 때문이다.

예를 들어 아래와 같이 max()라는 메서드가 정의된 `MyFunction` 인터페이스가 정의되어 있다고 가정하자.

```
interface MyFunction {
    public abstract int max(int a, int b);
}
```

위 인터페이스를 구현한 익명 클래스의 객체는 아래와 같이 생성가능하다.

```
MyFunction f = new MyFunction() {
    public int max(int a, int b) {
        return a > b ? a : b;
    };
}

int big = f.max(5, 3) // 익명 객체의 메서드를 호출
```

MyFunction 인터페이스에 정의된 메서드는 max()는 람다식 `(int a, int b) -> a > b ? a : b` 메서드의 선언부가 일치한다. 그래서 위 코드의 익명 객체를 람다식으로 아래와 같이 대체할 수 있다.

```
MyFunction f = (int a, int b) -> a > b ? a : b;
int big = f.max(5, 3) // 익명 객체의 메서드를 호출
```

이처럼 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는, <span style = "background-color:#FAF4C0">람다식도 실제로는 익명 객체이고, MyFunction 인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.</span>

지금까지 살펴본 것처럼, 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다. 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 <span style = "background-color:#FAF4C0">함수형 인터페이스</span>라고 부른다.

```
@FunctionalInterFace
interface MyFunction {
    public abstract int max(int a, int b);
}
```

단, <span style = "background-color:#FAF4C0">함수형 인터페이스에는 오직 하나의 추상 메서드</span>만 정의되어 있어야 한다는 제약이 있다. 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.

### 스트림

스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓았다. 데이터 소스를 추상화 하였다는 것은, 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다. 스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.

예를 들어, 문자열 배열과 같은 내용의 문자열을 저장하는 List가 있을 때,

```
String[] strArr = {"aaa", "bbb", "ccc"};
List<String> strList = Arrays.asList(strArr);
```

이 두 데이터 소스를 기반으로 하는 스트림은 다음과 같이 생성한다.

```
Stream<String> strStream1 = strList.stream();
Stream<String> strStream2 = Arrays.stream(strArr);
```

이 두 스트림으로 데이터 소스의 데이터를 읽어서 정렬하고 화면에 출력하는 방법은 다음과 같다. 데이터 소스가 정렬되는 것은 아니라는 것에 유의하자.

```
strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);
```

두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 완전히 동일하다. 스트림의 특징은 다음과 같다.

#### 스트림은 데이터 소스를 변경하지 않는다.

스트림은 데이터 소스로부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다는 차이가 있다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.

```
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

#### 스트림은 일회용이다.

스트림은 이터레이터처럼 일회용이다. 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.

#### 스트림은 작업을 내부 반복으로 처리한다.

스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다. 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다. 

#### 스트림의 연산

스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다. 마치 데이터베이스에 SELECT문으로 질의하는 것과 같은 느낌이다. 스트림이 제공하는 연산은 중간 연산과 최종 연산으로 분류할 수 있는데, 중간 연산은 연산결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다. 반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

```
stream.distinct().limit(5).sorted().forEach(System.out::println)
```

#### 지연된 연산

스트림 연산에서 한 가지 중요한 점은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다. 스트림에 대해 distinct()나 sort()같은 중간 연산을 호출해도 즉각적인 연산이 수행되는 것은 아니라는 것이다. 중간 연산을 호출하는 것은 단지 어떤 작업이 수행되어야 하는지를 지정해주는 것일 뿐이다.

#### Stream<Integer>와 IntStream

요소의 타입이 T인 스트림은 기본적으로 Stream\<T>이지만, 오토박싱 & 언박싱으로 인한 비효율을 줄이기 위해 데이터 소스의 요소를 기본형으로 다루는 스트림, `IntStream`, `LongStream` 등이 제공된다. 일반적으로 Stream<Integer> 대신 IntStream을 사용하는 것이 더 효율적이고, IntStream에는 int 타입의 값으로 작업하는데 유용한 메서드들이 포함되어 있다.

#### 병렬 스트림

스트림으로 데이터를 다룰 때의 장점 중 하나가 바로 병렬 처리가 쉽다는 것이다.

```
int sum = strStream.parallel().mapToInt(s -> s.length()).sum();
```