## 예외처리

### 예외처리

프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다. 이를 발생시점에 따라 <span style = "background-color:#FAF4C0">컴파일 에러와 런타임 에러</span>로 나눌 수 있는데, 글자 그대로 '컴파일 에러'는 <span style = "background-color:#FAF4C0">컴파일 할 때 발생하는 에러</span>이고 <span style = "background-color:#FAF4C0">프로그램의 실행도중에 발생하는 에러</span>를 '런타임 에러'라고 한다.

- 컴파일 에러 : 컴파일 시에 발생하는 에러
- 런타임 에러 : 실행 시에 발생하는 에러
- 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것

소스코드를 컴파일 하면 컴파일러가 소스코드(.java)에 대해 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사를 수행하여 오류가 있는지를 알려 준다. 컴파일러가 알려 준 에러들을 모두 수정해서 컴파일을 성공적으로 마치고 나면, 클래스 파일(.class)이 생성되고, 생성된 클래스 파일을 실행할 수 있게 되는 것이다.

하지만 컴파일을 에러없이 성공적으로 마쳤다고 해서 프로그램의 실행 시에도 에러가 발생하지 않는 것은 아니다. 컴파일러가 소스코드의 기본적인 사항은 컴파일 시에 모두 걸러 줄 수는 있지만, 실행도중에 발생할 수 있는 잠재적인 오류까지 검사할 수 없기 때문에 컴파일은 잘되었어도 실행 중에 에러에 의해서 잘못된 결과를 얻거나 프로그램이 비정상적으로 종료될 수 있다. 예를 들면 프로그램이 실행 중 동작을 멈춘 상태로 오랜 시간 지속되거나, 갑자기 프로그램이 실행을 멈추고 종료되는 경우 등이 이에 해당한다.

자바에서는 실행 시 발생할 수 있는 프로그램 오류를 <span style = "background-color:#FAF4C0">에러, 예외</span> 두 가지로 구분하였다.

에러는 <span style = "background-color:#FAF4C0">메모리 부족이나 스택오버플로우</span>와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것이다.

- 에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
- 예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

![image](https://user-images.githubusercontent.com/78870076/125567300-1f03432e-ee04-460b-958b-128f2fc37296.png)

사진 출처 : [https://tenlie10.tistory.com/27](https://tenlie10.tistory.com/27)

- Excpetion 클래스 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
- RuntimeException 클래스 : 프로그래머의 실수로 발생하는 예외

#### 예외 처리하기 - try - catch

프로그램의 실행도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다. 예외처리란, <span style = "background-color:#FAF4C0">프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다.</span>

- 정의 : 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성하는 것
- 목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외는 JVM의 '예외처리기'가 받아서 예외의 원인을 화면에 출력한다. 예외를 처리하기 위해서는 `try - catch`문을 사용한다.

```
try {
    ... // 예외가 발생할 가능성이 있는 문장들
} catch (Exception1 e1) {
    ... // Exception1이 발생했을 경우, 이를 처리하기 위한 문장
} ...
```

try - catch문에서, 예외가 발생한 경우와 발생하지 않았을 때의 흐름(문장의 실행순서)이 달라진다.

- try 블럭 내에서 예외가 발생한 경우,
    - 발생한 예외와 일치하는 catch 블럭이 있는지 확인한다.
    - 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch 블럭을 찾지 못하면, 예외는 처리되지 못한다.

- try 블럭 내에서 예외가 발생하지 않은 경우,
    - catch 블럭을 거치지 않고 전체 try - catch문을 빠져나가서 수행을 계속한다.

#### printStackTrace()와 getMessage()

예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, `getMessage()`와 `printStackTrace()`를 통해서 이 정보들을 얻을 수 있다.

- printStackTrace() : 예외발생 당시의 호출스택에 있었던 메소드의 정보와 예외 메시지를 화면에 출력한다.
- getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

#### 예외 발생시키기

키워드 `throw`를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있으며, 방법은 다음과 같다.

- 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다. 
    - Exception e = new Exception("고의 발생");
- 키워드 throw를 이용해서 예외를 발생시킨다.
    - throw e;

#### 메소드에 예외 선언하기

예외를 처리하는 방법에는 `try - catch`문을 사용하는 것 외에, 예외를 메소드에 선언하는 방법이 있다. 메소드에 예외를 선언하려면, 메소드의 선언부에 키워드 `throws`를 사용해서 메소드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다. 그리고 예외가 여러 개일 경우에는 쉼표(,)로 구분한다.

```
void method() throws Exception1, Exception2, ... {
    ... // 메소드 내용
}
```

이렇게 예외를 선언하면, 이 예외뿐만 아니라 그 자손타입의 예외까지도 발생할 수 있다는 점에 주의한다. 앞서 오버라이딩에서 살펴본 것과 같이, 오버라이딩할 때는 단순히 선언된 예외의 개수가 아니라 상속관계까지 고려해야 한다.

#### finally 블럭

`finally` 블럭은 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try - catch문의 끝에 선택적으로 덧붙여 사용할 수 있으며, try - catch - finally의 순서로 구성된다.

```
try {
    ...
} catch (Exception1 e1) {
    ...
} finally {
    ... // 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣음.
}
```