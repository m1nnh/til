## :star: DBMS

## 크레이지 아케이드 해피 서버와 드림 서버

1주차에서는 로컬에 서버를 구축했고, 2주차에는 클라이언트와 서버를 분리했다. 이번 3주차의 핵심은 서버단에서 `DBMS`와 `DB`를 분리하는 것이다. 초등학생 때 주로 하던 게임 크레이지 아케이드 게임에는 해피 서버와 드림 서버가 있다. 해피 서버 사용자와 드림 서버 사용자는 서로 만날 수가 없다. 어떤 로직 때문에 만날 수 없었을까?

### 서버단(Server Program + Back-end Language + DBMS)

`Server Program` / `Back-end Language` / `DBMS` 세 파트를 통틀어서 서버라고 한다. 크레이지 아케이드 게임에서 해피 서버를 운영하던 도중 사용자가 너무 많아져 서버를 새로 만들어야한다고 생각해보자. 그럼 이 서버단을 하나 더 구축해야 했고 아래와 같은 문제들이 발생했다.

- 해피 서버 사용자와 드림 서버 사용자가 만나서 게임할 수 없다.
- 유능한 해커에게 서버가 털리면 모든 사용자들의 정보가 날라간다.
- APM중 A와 P는 같은 로직으로 만들어져 중복된다.

이러한 문제는 M을 분리하여 쉽게 해결할 수 있다. `DBMS`인 M을 분리하여 관리한다고 생각해보자. 사용자가 훨씬 많아져 서버를 또 만든다해도 1개의 데이터베이스로 모든 서버에 접근이 가능하다. DB를 외부에서 관리하기 때문에 보안상으로도 훨씬 안정적이다.

### PHPMyadmin vs DataGrip

PHPMyadmin | DataGrip
:---: | :---:
PHP가 있어야함 | 독립적 데이터베이스
1:1 관계 | 1:n의 관계
속도가 빠름 | 확장성과 효율성이 좋음

## 관계형 데이터베이스(RDBMS)

### Ecxel vs Database

Ecxel | Database
:---: | :---:
파일 생성 | DB 생성
Sheet | Table
Data | Data

### 데이터 모델링

우리는 잘 정데된 데이터가 필요하다. 그러기 위해서는 `데이터 모델링`을 반드시 거쳐야 한다. 데이터 설계라고도 불리는 데이터 모델링은 현실 세계를 표로 바꿔주는 작업이다. 추상화라고 볼 수도 있는데, 아래의 세 단계를 거친다.

- 시스템 설계단계 (기획/ 기능 / 회면)
- 논리 단계 (Entity, Attribute, Relation)
- 물리 단계

에브리타임 앱을 예로 들면 시스템 설계단계에서는 우선 한 줄로 앱이 무슨 역할을 하는지 알아내야 한다. 에브리타임을 예로 들면 `학생들이 글을 쓰고 공유하는 커뮤니티 앱`이라고 지정할 수 있다. 논리적 모델은 이러한 것을 가지고 EAR을 뽑아내는 것이다. E는 Entity로 속성들의 집합이다. Attribute는 어떤 객체의 속성들이고 Relation은 관계를 나타낸다. 에브리타임을 예로 들면 게시판, 글, 댓글 등 전체적은 집합들은 `Entity`이고 이 안에 이름, 제목, 내용등 집합의 속성들은 `Attribute`라 한다. 집합간의 관계가 있을 수도 있고 속성끼리 관계가 있을 수도 있다. 이러한 관계들을 `Relation`이라 한다. Relation은 `primary key` / `foreign key` / `join` 등으로 매칭이 된다.

## NoSQL

지금까지 RDBMS 즉 관계형 데이터베이스에 대해서만 알아보았다. 그렇다면 `NoSQL`은 무엇일까? 한마디로 말하자면 SQL 형태가 아닌 모든 것들을 뜻한다. key - value 형태의 DBMS 혹은 Graph DBMS처럼 SQL 형태가 아니기만 하면 된다.