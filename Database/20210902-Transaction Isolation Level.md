## 트랜잭션 격리 수준 (Transaction Isolation Level)

트랜잭션에 일관성 없는 데이터를 허용하도록 하는 수준

### Isolation Level의 필요성

데이터베이스는 `ACID` 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다. 따라서 `Locking`을 통해, 트랜잭션이 데이터베이스를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다. 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다. 그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다. 따라서 최대한 효율적인 Locking 방법이 필요하다.

### Isolation Level의 종류 

#### Read Uncommitted (Level 0)

트랜잭션에 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. -> 데이터 불일치 발생 가능성 -> 일관성 유지 불가

- e.g) 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은 트랜잭션이지만 데이터 B를 읽을 수 있다.

#### Read Committed (Level 1)

트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기한다. Commit이 이루어진 트랜잭션만 조회가 가능하며, SQL 서버가 Default로 사용하는 계층이다.

- e.g) 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능하다.

#### Repeatable Read (Level 2)

트랜잭션이 완료될 때까지 `select` 문장이 사용하는 모든 데이터에 `shared lcok`이 걸리는 계층이다. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능하다.

#### Serializable (Level 3)

트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층이다. 완벽한 읽기 일관성 모드를 제공한다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.

### 낮은 단계 계층을 활용할 때 발생하는 현상

- Dirty Read 
    - 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
    - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우
- Non-Repeatable Read 
    - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨지는 현상
- Phantom Read 
    - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타는 현상
    - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상이다.

    