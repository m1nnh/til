## :star:  Data Models and Performance

### :speech_balloon: 성능데이터 모델링의 개요

#### 1. 성능 데이터 모델링의 정의
- 데이터베이스 성능 향상을 목적으로 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인 구조, PK, FK 등 여러 가지 성능과 관련 된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

#### 2. 성능 데이터 모델링 수행시점
- 분석/설계 단계에서 데이터베이스 처리 성능을 향상 시킬 수 있는 방법을 주도 면밀하게 고려해야 한다.

#### 3. 성능 데이터 모델링 고려 사항
- 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
- 데이터베이스 용량 산정을 수행한다.
- 데이터베이스에 발생 되는 트랜잭션의 유형을 파악한다.
- 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
- 이력 모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
- 성능 관점에서 데이터 모델을 검증한다.

### :speech_balloon: 정규화와 성능

#### 1. 정규화를 통한 성능 향상 전략
- 데이터 모델링을 하면서 정규화를 하는 것은 기본적으로 데이터에 대한 중복성을 제거하여 주고 데이터가 관심사 별로 처리 되는 경우가 많기 때문에 성능이 향상 되는 특징을 가지고 있다.
- 데이터베이스에서 데이터를 처리할 때 성능이라고 하면 **조회 성능**과 **입력/수정/삭제** 성능의 두 부류로 구분 된다.
- 정규화를 수행하면 데이터처리의 성능은 향상 되며, 데이터의 조회 처리 트랙잭션시에 성능이 저하가 될 수 있다.

### 2. 함수적 종속성
- 함수의 종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다. 이때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다.
- 기본적으로 데이터는 속성간의 함수 종속성에 근거하여 정규화 되어야 한다. 프로젝트 수행에서 정규화는 선택사항이 아니라 필수사항이다.

### :speech_balloon: 반정규화와 성능

#### 1. 반정규화를 통한 성능향상 전략
- 반정규화는 정규화를 수행하지 않는다라는 뜻이다. 여기서 반은 Half가 아니라 De-Normalization(반대하다)이다.
- 협의의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화 된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다.
- 데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하 되거나 경로가 너무 멀어 조인으로 인한 성능 저하가 예상 되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상 되는 경우 반정규화를 수행하게 된다.
- 프로젝트에서는 설계 단계에서 반정규화를 적용하게 되는데 반정규화를 기술적으로 수행하지 않는 경우에는 다음과 같은 현상이 발생된다.
    - 성능이 저하된 데이터베이스가 생성될 수 있다.
    - 구축 단계나 시험 단계에서 반정규화를 적용할 때 수정에 따른 노력 비용이 많이 들게 된다.
- 반정규화 절차

    1. 반정규화 대상 조사(범위처리 빈도수, 범위, 프로세스, 조인 개수)
    2. 다른 방법유도 검토(뷰 테이블, 클러스터링 적용, 인덱스의 조정, 응용애플리케이션)
    -> 반정규화 적용 (테이블, 속성, 관계)

#### 2. 반정규화 기법
- 테이블 병합 
    - 1:1 관계 테이블 병합
    - 1:M 관계 테이블 병합
    - 슈퍼/서브타입 테이블 병합
- 테이블 분할
    - 수직 분할 : 칼럼 단위의 테이블을 디스크 I/O로 분산처리 하기 위해 테이블을 1:1로 분리하여 성능 향상
    - 수평 분할 : 로우 단위로 집중 발생 되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상 하기 위해 로우 단위로 테이블을 쪼깸
- 테이블 추가
    - 중복 테이블 추가
    - 통계 테이블 추가
    - 이력 테이블 추가
    - 부분 테이블 추가
- 칼럼 반정규화
    - 중복 칼럼 추가
    - 파생 칼럼 추가
    - 이력 테이블 칼럼 추가
    - PK에 의한 칼럼 추가
    - 응용시스템 오작동을 위한 칼럼 추가
- 관계 반정규화
    - 중복관계 추가

#### 3. 대량 데이터에 따른 성능
- 로우 체이닝 : 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
- 로우마이그레이션 : 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장 하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- RANGE PARTITION : 대상 테이블이 날짜 또는 숫자 값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리 되는 경우
- LIST PARTITION : 지점, 사업소 등 핵심적인 코드 값으로 PK가 구성 되어 있고 대량의 데이터가 있는 테이블의 경우
- HASH PARTITION : 지정된 HASH 조건에 따라 해시 알고리즘이 적용 되어 테이블이 분리
- 테이블에 대한 수평 분할/수직 분할의 절차

    1. 데이터 모델링을 완성한다.
    2. 데이터베이스 용량 산정을 한다.
    3. 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.
    4. 칼럼 단위로 집중화 된 처리가 발생하는지, 로우 단위로 집중화 된 처리가 발생 되는지 분석하여 집중화 된 단위로 테이블을 분리하는 것을 검토한다.

### :speech_balloon: 데이터베이스 구조와 성능

#### 1. 슈퍼타입/서브타입 모델의 성능 고려 방법
- 이 모델이 자주 쓰이는 이유는 업무를 구성하는 데이터의 특징을 공통과 차이점의 특징을 고려하여 효과적으로 표현할 수 있기 대문이다.
- 즉 공통의 부분을 슈퍼타입으로 모델링하고 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브 엔터티로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변화늘 할 때 선택의 폭을 넓힐 수 있는 장점이 있다.
- 슈퍼/서브타입에 대한 변환을 잘못하면 성능이 저하되는 이유는 트랜잭션 특성을 고려하지 않고 테이블이 설계 되어서 그렇다.

    1. 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지 되어 Union 연산에 의해 성능이 저하될 수 있다.
    2. 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합 되어 있어 불필요 하게 많은 양의 데이터가 집약 되어 있어 성능이 저하 되는 경우가 있다.
    3. 트랜잭션은 항상 슈퍼 + 서브 타입을 공통으로 처리 하는데 개별로 유지 되어 있거나 하나의 테이블로 집약 되어 있어 성능이 저하 되는 경우가 있다.

#### 2. 슈퍼/서브 타입 데이터 모델의 변환 기술
- 개별로 발생 되는 트랜잭션에 대해서는 개별 테이블로 구성
- 슈퍼타입 + 서브타입에 대해 발생 되는 트랜잭션에 대해서는 슈퍼 + 서브타입 테이블로 구성
- 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

#### 3. 인덱스 특성을 rhfugks PK/FK DB 성능 향상
- 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성 되어 있을 대 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타낸다.
- 앞쪽에 위치한 속성의 값이 가급적 '=' 아니면 최소한 범위 'BETWEEN' '<>'가 들어와야 효율적이다.
- 물리적인 테이블에 FK 제약을 걸었을 때는 반드시 FK 인덱스를 생성 하도록 하고 FK 제약이 안걸렸을 경우에는 FK 인덱스를 생성하는 것을 기본 정책으로 하되 발생되는 **트랜잭션에 의해 거의 활동 되지 않았을 때에만** FK 인덱스를 지우는 방법으로 하는 것이 적절한 방법
- FK에도 인덱스를 생성할 필요가 있다.

### :speech_balloon: 분산 데이터베이스와 성능

#### 1. 분산 데이터베이스의 개요
- 여러 곳으로 분산 되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
- 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산 되어 있는 데이터들의 모이, 물리적 Site 분산, 논리적으로 사용자 통합 공유

#### 2. 분산 데이터베이싀 투명성(Transparency)
- 분산 데이터베이스가 되기 위해서는 6가지 투명성을 만족해야 한다.   
1. 분할 투명성(단편화) : 하나의 논리적 관계가 여러 단편으로 분할 되어 각 단편의 사본이 여러 사이트에 저장
2. 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요, 위치 정보가 시스템 카탈로그에 유지 되어야 함
3. 지역 사상 투명성 : 지역 DBMS와 물리적 DB사이의 매핑 보장, 각 지역 시스템 이름과 무관한 이름 사용 가능
4. 중복 투명성 : DB 객체가 여러 사이트에 중복 되어 있는지 알 필요가 없는 성질
5. 장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 Transction의 원자성 유지
6. 병행 투명성 : 다수 Transaction 동시 수행시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 규현

#### 3. 분산 데이터베이스의 장 단점
- 장점 : 지역 자치성, 신뢰성 가용성, 효용성, 융통성, 빠른 응답속도, 비용절감, 각 지역 사용자 요구 수용
- 단점 : 비용증가, 오류의 잠재성 증대, 설계 관리의 복잡성, 불규칙한 응답 속도, 통제의 어려움, 데이터 무결성 위협

#### 4. 분산 데이터베이스 적용 기법
- 테이블 위치 분산 : 설계된 테이블을 본사와 지사 단위로 분산
- 테이블 분할 분산 : 각각의 테이블을 쪼개어 분산
    - 수평 분할 : 로우 단위로 분리
    - 수직 분할 : 칼럼 단위로 분리
- 테이블 복제 분산 : 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
    - 부분 복제 : 마스터 데이터베이스에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치
    - 광역 복제 : 마스터 데이터베이스 테이블의 내용을 각 지역이나 서버에 존재
- 테이블 요약 분산 : 지역 간에 또는 서버 간에 데이터가 비슷 하지만 서로 다른 요형으로 존재하는 경우
    - 분석 요약 : 동일한 테이블 구조를 가지고 있으면서 분산 되어 있는 동일한 내용의 데이터를 이용 하여 통합 된 데이터를 산출하는 방식
    - 통합 요약 : 분산 되어 있는 다른 내용의 데이터를 이용하여 통합 된 데이터를 산출하는 방식

#### 5. 분산 데이터베이스 설계를 고려해야 하는 경우
- 성능이 중요한 사이트
- 공통 코드, 기준 정보, 마스터 데이터의 성능 향상
- 실시간 동기화가 요구 되지 않는 경우 (거의 실시간의 업무적인 특징을 가지고 있는 경우)
- 특정 서버에 부하가 집중 되어 부하를 분산
- 백업 사이트를 구성하는 경우
