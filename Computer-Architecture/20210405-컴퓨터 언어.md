## :star: 컴퓨터 언어 (Reference : 컴퓨터 구조 및 설계 하드웨어/소프트웨어 인터페이스)

### 1. 서론
컴퓨터 언어에서 단어를 명령어(Instruction)라 하고 그 어휘를 명령어 집합(Instruction Set)이라고 한다. 이 장에서는 명령어의 표현 방식을 배운다. 표현 방식을 배우면 컴퓨터의 가장 큰 비밀인 **내장 프로그램 개념(Stored - Program Concept)** 을 이해할 수 있다.
- 내장 프로그램 개념 : 여러 종류의 데이터와 명령어를 메모리에 숫자로 저장할 수 있다는 개념이다.

### 2. 하드웨어 연산
MIPS 산술 명령어는 반드시 한 종류의 연산만 지시하며 항상 변수 세 개를 갖는 형식을 엄격히 지킨다.
```
add a, b, c # a = sum(b, c)
add a, a, d # a = sum(a, d)
add a, a, e # a = sum(a, e)
```

### 3. 피연산자
High Level Language 프로그램과는 달리 산술 명령어의 피연산자에는 제약이 있다. **레지스터(Register)** 라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만을 사용할 수 있다. MIPS 구조에서 레지스터의 크기는 32비트이다. MIPS에서는 **32비트가 한 덩어리로 처리되는 일**이 매우 빈번하므로 이것을 **워드(word)** 라고 부른다.

**메모리 피연산자**
배열이나 구조체 같은 자료구조는 메모리에 보관한다. 앞에서 설명한 바와 같이 MIPS 산술연산은 레지스터에서만 실행되므로 메모리와 레지스터 간에 데이터를 주고받는 명령어가 있어야 한다. 이런 명령어를 **데이터 전송 명령어(Data Transfer Instruction)** 라 한다. 메모리에 기억된 데이터 워드에 접근 하려면 명령어가 메모리 주소(Address)를 지정해야 한다. 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령을 **적재(load)** 라 한다. 메모리 주소는 명령어의 상수 부분과 두 번째 레지스터 값의 합으로 구해진다. MIPS에서 이 명령어의 실제 이름인 **lw(Load Word)** 이다. 적재와 반대로 레지스터에서 메모리로 데이터를 보내는 명령을 **저장(Store)** 이라 한다. MIPS에서 이 명령어의 실제 이름은 **sw(Store Word)** 이다.

**상수 또는 수치 피연산자**
적재 명령을 사용하지 않는 방법은 피연산자 중 하나가 상수인 산술연산 명령어를 제공하는 것이다. 이 상수를 **수치(Immediate) 피연산자**라고 한다. 수치 피연선자를 갖는 덧셈 명령어는 **addi**이다.
```
addi $s3, $s3, 4 # $s3 = $s3 + 4
```
상수 0은 다른 역할을 하는데 유용한 여러 변형을 제공함으로써 단순한 명령어 집합을 가능케 한다. 예를 들면 복사(Move)연산은 피연산자 중 하나가 0인 add 명령어이다. 따라서 MIPS에서는 레지스터 $zero를 값 0으로 묶어 두도록 회로가 구현되어 있다. 쓰이는 빈도가 높으면 상수를 명령어에 포함시키도록 하는 것이 **자주 생기는 일을 빠르게** 하라는 좋은 아이디어의 또 다른 예가 된다. 

### 4. 부호있는 수와 부호없는 수
컴퓨터의 모든 정보는 **이진 자리 수(Binary Digit)** 즉 비트(bit)로 구성되므로 비트가 계산의 기본 단위가 된다. 워드는 **오른쪽에서 왼쪽으로** 0, 1, 2, 3과 같이 번호를 붙인다.
- LSB(Least Significant Bit) : MIPS 워드에서 가장 오른쪽 비트
- MSB(Most Significant Bit) : MIPS 워드에서 가장 왼쪽 비트 -> Sign bit(음수인지 양수인지 구분해준다.)

### 5. 명령어의 컴퓨터 내부 표현
어셈블리 언어와 구별하기 위하여 명령어를 숫자로 표현한 것을 **기계어(Machine Language)** 라고 하고, 이런 명령어들의 시퀀스를 **기계 코드(Machine Code)** 라 한다.

**MIPS 명령어의 필드**
![image](https://user-images.githubusercontent.com/78870076/113538733-f479c500-9616-11eb-99a2-112f530b0fc4.png)

- op : 명령어가 실행할 연산의 종류로서 연산자(Opcode)라고 부른다.
- rs : 첫 번째 근원지(Source) 피연산자 레지스터이다.
- rt : 두 번째 근원지 피연산자 레지스터이다.
- rd : 목적지(Destination) 레지스터, 연산 결과가 기억된다.
- shamt : 자리이동(Shift)량
- funct : 기능(Function), op 필드에서 연산의 종류를 표시하고 funct 필드에서는 그중의 한 연산을 구체적으로 지정한다. 기능코드라 부르기도 한다.

**설계 원칙 1: 간단하게 하기 위해서는 규칙적인 것이 좋다.**
**설계 원칙 2: 작은 것이 더 빠르다.**
**설계 원칙 3: 좋은 설계에는 적당한 절충이 필요하다.**

### 6. 논리연산 명령어
초기의 컴퓨터는 워드 전체에 대한 처리에만 관심을 가졌으나, 워드 내 일부 비트들에 대한 연산, 심지어는 개개 비트에 대한 연산도 필요하다는 것이 곧 명백해졌다. 워드 내에 8비트로 저장된 문자를 검사하는 작업이 이러한 연산의 한 예이다. 뒤를 이어, **비트들을 워드로 묶는(Packing)** 작업과 **워드를 비트 단위로 나누는(Unpacking)** 작업을 간단하게 하는 명령어들이 프로그래밍 언어와 명령어 집합에 추가되었다. 이러한 명령어들을 논리연산 명령어라 부른다.
- sll(Shift Left Logical) : 왼쪽 자리이동
- srl(Shift Right Logical) : 오른쪽 자리이동
```
sll $t2, $s0, 4 # reg $t2 = reg $s0 << 4 bits
```

- AND : 둘다 1이어야만 1이된다. AND는 어떤 비트 패턴에서 0의 위치에 해당하는 비트들을 강제로 0으로 만드는데 사용할 수 있다. AND와 함께 쓰이는 이러한 비트 패턴은 일부 비트를 감추는 역할을 하기 때문에 마스크(mask)라고 부른다.
- OR : 하나만 1이어도 1이된다.
- NOT : 1이면 0으로 0이면 1로 변환한다.

### 7. 판단을 위한 명령어
컴퓨터가 단순한 계산기와 다른 점은 판단 기능이 있다는 것이다. 입력 데이터나 연산 결과에 따라 다른 명령어를 실행할 수 있다. 프로그래밍 언어에서는 보통 if 문장으로 판단 기능을 표현한다.

```
beq register1, register2, L1
```

register1과 register2의 값이 같으면 L1에 해당하는 문장으로 가라는 뜻이다. **beq는 branch if equal**을 의미한다.

```
bne register1, register2, L1
```

register1과 register2의 값이 같지 않으면 L1으로 가라는 뜻이다. **bne는 branch not equal**을 의미한다. beq와 bne 두 명령어를 **조건부 분기(Conditional Branch)** 라 부른다.

**순환문**
판단 기능은 둘 중의 하나를 선택하는 데도 중요하지만 계산의 반복에도 중욯다. 두 경우이 모두 같은 어셈블리 명령어가 사용된다.

### 8. 하드웨어의 프로시저 지원
**프로시저(Procedure)** 나 함수는 이해하기 쉽고 재사용이 가능하도록 프로그램을 조회하는 방법 중의 하나이다. 프로시저는 소프트웨어에서 **추상화**를 구현하는 방법이다. 프로그램이 프로시저를 실행할 때 다음과 같이 여섯 단계를 거친다.
- 프로시저가 접근할 수 있는 곳에 인수를 넣는다.
- 프로시저로 제어를 넘긴다.
- 프로시저가 필요로 하는 메모리 자원을 획득한다.
- 필요한 작업을 수행한다.
- 호출한 프로그램이 접근할 수 있는 장소에 결과 값을 넣는다.
- 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다.

MIPS 어셈블리 언어는 레지스터를 할당할 뿐 아니라 프로시저를 위한 명령어도 제공한다. 지정된 주소로 점프하면서 동시에 다음 명령어의 주소를 $ra 레지스터에 저장하는 명령어으로 **jal 명령어(Jump and Link Instruction)** 라 부른다. 이름에서 link는 프로시저 종료 후 올바른 주소로 되돌아올 수 있도록 호출한 곳과 프로시저 사이에 주소 또는 링크를 형성한다는 뜻이다. 레지스터 $ra에 기억되는 이 링크를 **복귀 주소**라고 부른다. 한 프로시저가 여러 곳에서 호출될 수 있으므로 복귀 주소는 꼭 필요하다. 


