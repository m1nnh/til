## 자바와 절차적/구조적 프로그래밍

### 자바 프로그램의 개발과 구동

현실 세계에서 컴퓨터를 구동하기 위해서는 물리적 컴퓨터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요하다. 거기에 더해 소프트웨어를 개발할 수 있는 개발 도구가 필요하다.

현실 시계 | 가상 세계(자바 월드) | 도구
:--- | :--- | :---
소프트웨어 개발 도구 | JDK - 자바 개발 도구 | JVM용 소프트웨어 개발 도구
운영체제 | JRE - 자바 실행 환경 | JVM용 OS
하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계 | 가상의 컴퓨터

현실 세계에서 소프트웨어, 즉 프로그램은 개발자가 개발 도구를 이용해 개발하고 운영체제를 통해 물리적 컴퓨터인 하드웨어 상에서 구동된다. 자바가 만들어 주는 가상 세계도 이와 마찬가지다. 자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.

JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다. 자바가 이런 구조를 택한 이유는 기존 언어로 작성한 프로그램은 운영체제에 맞게 설치 파일을 따로 준비해야 했던 불편함이 있었기 때문이다.

```
JDK : Java Development Kit
JRE : Java Runtime Environment
JVM : Java Virtual Machine
```

`프로그램이 메모리를 사용하는 방식`

코드 실행 영역 | 데이터 저장 영역
:---: | :---:


위의 그림은 하나의 프로그램이 실행될 때 프로그램이 메모리를 사용하는 방식을 간략하게 보여준다. 기계어를 포함한 모든 프로그래밍 언어의 공통된 메모리 사용 방식이다. 객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용한다.

```
코드실행 영역

데이터 저장 영역
    - 스태틱(static) 영역
    - 스택(stack) 영역
    - 힙(Heap) 영역
```

메모리의 코드 실행 영역을 공부하면 컴퓨터의 작동 원리를 이해하는 데 큰 도움이 된다.

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산

절차적 프로그래밍을 한마디로 표현하자면 **goto**를 쓰지 말라는 것이다. 자바에서는 const 역할을 **final**이 대신하고 있다. goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문에 goto를 사용하지 못하게 한 것이다.

구조적 프로그래밍은 함수를 쓰라는 것이다. 함수를 쓰면 좋은 이유는 우선 **중복 코드**를 한 곳에 모아서 관리할 수 있고, **논리를 함수 단위로 분리**해서 **이해하기 쉬운 코드**를 작성할 수 있기 때문이다.여기에 더해 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 **지역 변수**를 쓰라는 것도 있다.

그럼 자바 언어에서 이러한 절차적/구조적 프로그래밍의 유산은 **순서도**와 **제어문**이다. 함수는 **객체 지향 언어**에서라면 메서드와 같은 것이다. 따라서 절차적/구조적 프로그래밍의 유산은 **메서드**안에서 확인할 수 있다. 객체 지향 프로그래밍에서 제어문이 존재할 수 있는 유일한 공간은 바로 **메서드 내부**이기 때문이다.

```
함수(Function) = 메서드(Method)
```

함수와 메서드의 차이점을 찾는다면 함수는 **클래스나 객체와 아무 관계가 없지만** 메서드는 반드시 **클래스 정의 안에** 존재해야 한다는 것이다. **객체 지향 언어에서 클래스 외부에 존재할 수 있는 것은 없다.**

### 다시 보는 main() 메서드 : 메서드 스택 프레임
main() 메서드는 프로그램이 실행되는 **시작점**이다. main() 메서드가 실행될 때 메모리, 특히 T 메모리(스태틱, 스택, 힙)에는 어떤 일이 일어날까?

```
public class Start {
    public static void main(String [] args) {
        System.out.println("Hello OOP!!!");
    }
}
```

```
T 메모리

스태틱 영역 - 클래스들의 놀이터
스택 영역 - 메서드들의 놀이터
힙 영역 - 객체들의 놀이터
```

우선 **JRE(Java Runtime Environment)** 는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다. main() 메서드가 존재가 확인되면 **JRE**는 프로그램 실행을 위한 사전 준비에 착수한다. **가상의 기계인 JVM에 전원을 넣어 부팅하는 것이다.** 부팅된 **JVM(Java Virtual Machine)** 은 목적 파일을 받아 그 목적 파일을 실행한다. JVM이 맨 먼저 하는 일은 **전처리**라고 하는 과정이다. 모든 자바 프로그램이 반드시 포함하게 되는 패키지가 있다. 바로 java.lang 패키지다. JVM은 가장 먼저 java.lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다. 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓는다.

`main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들`

```
java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다.
import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.
```

이제 main() 메서드가 놀기 위해 스택 프레임이 스택 영역에 할당된다. 조금 더 정확히 이야기하자면 **여는 중괄호를 만날 때마다 스택 프레임이 하나씩 생긴다.** 클래스 정의를 시작하는 여는 중괄호만 빼고 말이다. 그리고 나서 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해야 한다. 즉, **메서드 인자(들)의 변수 공간을 할당하는 것이다.** 이렇게 하고 나서 구문이 실행된다. 구문이 실행되면 T 메모리에는 변화가 없다. 메모리에서 코드 실행 공간은 별도로 있었다. **여는 중괄호로 스택 프레임이 만들어지고 닫는 중괄호로 스택 프레임이 소멸된다.** main() 메서드가 **시작점**이라고 했는데 **끝**이기도 하다. main() 메서드가 끝나면 **JRE**는 **JVM**을 종료하고 **JRE** 자체도 운영체제 상의 메모리에서 사라진다. 그럼 **T 메모리에도 이제 그 운명을 다하고 사라지게 되는 것**이다.

<img width="479" alt="스크린샷 2021-04-12 오후 10 30 58" src="https://user-images.githubusercontent.com/78870076/114402458-ced45900-9bde-11eb-9112-0fcfd0c372d5.png">


### 변수와 메모리: 변수! 너 어디 있니?

```
public class Start2 {
    public static void main(String [] args) {
        int i;
        i = 10;

        double d = 20.0;
    }
}
```

Start.java 때와 다르지 않다. Start 자리에 Start2가 들어왔을 뿐이다. 하지만 `int i;`의 명령어는 메모리에 4바이트 크기의 **정수 저장 공간을 마련**하라는 것이다. 컴퓨터(JVM)는 충실하게 `i` 변수를 위한 공간을 마련하는데, main() 스택 프레임에 밑에서부터 차곡차곡 공간을 마련한다.

### 블록 구문과 메모리: 블록 스택 프레임

```
public class Start3 {
    public static void main(String [] args) {
        int i = 10;
        int k = 20;

        if (i == 10) {
            int m = k + 5;
            k = m
        }
        else {
            int p = k + 10;
            k = p;
        }

        // k = m + p;
    }
}
```

다음으로 if 블록이다. if는 조건에 따라 분기를 일으킬 것이다. 여기서는 else 말고 if문이 실행 되는데 if 문도 main() 스택 프레임 영역에 if 스택 프레임 영역이 생긴다. 그리고 if 스택 프레임은 if 문의 **닫힌 괄호**를 만나게 되면 사라진다.

### 지역 변수와 메모리: 스택 프레임에 갇혔어요!
변수는 T 메모리에서 세 영역 모두 존재한다. 그런데 세 군데 각각에 있는 변수는 각기 다른 목적을 가진다. 그리고 각각의 이름도 지역 변수, 클래스 멤버 변수, 객체 맴버 변수로 다르다. `지역 변수`는 **스택 영역**에서 일생을 보낸다. 그것도 **스택 프레임 안**에서 일생을 보내게 된다. 따라서 스택 프레임이 사라지면 함께 사라진다. `클래스 멤버 변수`는 **스태틱 영역**에서 일생을 보낸다. 스태틱 영역에 한번 자리 잡으면 JVM이 종료될때까지 고정된 상태로 그 자리를 지킨다. `객체 멤버 변수`는 **힙**에서 일생을 보낸다. 객체 멤버 변수들은 객체와 함께 `가비지 컬렉터`라고 하는 메모리 회수기에 의해 일생을 마치게 된다.

### 메서드 호출과 메모리: 메서드 스택 프레임2

```
public class Start4 {
    public static void main(String [] args) {
        int k = 5;
        int m;

        m = square(k);
    }

    private static int square(int k) {
        int result;

        k = 25;

        result = k;

        return result;
    }
}
```

위에 main() 메서드는 똑같이 앞에서 설명한 T 메모리 구조랑 같은 것이고, square 메서드는 스태틱 영역에 자리잡는다. 그리고 스택 영역에 square() 스택 프레임이 자리 잡힐 것이고 그 프레임 안에 지역 변수들이 자리 잡을 것이다. 또한 main() 메서드의 k와 sqare 메서드의 k는 실제로는 서로 별도의 변수 공간을 가진다. 그래서 이것을 전문 용어로 **Call By Value(값에 의한 호출)** 이라 한다. 그리고 square() 스택 프레임은 square 메서드의 닫힌 괄호를 만날 때 사라진다. T 메모리 안에서 서로 다른 스택 프레임들 간에 지역변수들 끼리 접근이 불가능하다. 이유는 아래와 같다.

1. 그것이 이치에 맞기 때문이다. 메서드는 서로의 고유 공간이고, 서로 침범하면 무단 침입으로 자바 월드에 문제를 유발할 수 있기 때문이다.

2. 포인터 문제 때문이다. square() 메서드에서 main() 메서드 내부의 지역변수 m에 접근한다고 하면 m의 위치를 명확히 알아야 하는데, 그 위치를 명확히 알기 위해서는 바로 m 변수의 메모리 위치, 즉 포인터라고 읽고 메모리 주소 값이라 이해해야 하는 그 값을 알아야 한다.

3. 예제의 코드는 square() 메서드를 main() 메서드 혼자서 호출하는 코드지만 실전에서 사용되는 메서드는 다양한 곳으로부터 호출된다.

### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
메서드 사이에 값을 공유하는 방법은 바로 **전역 변수**를 사용하는 것이다.

```
public class Start5 {
    static int share;

    public static void main(String [] args) {
        share = 55;
        int k = fun(5, 7);

        System.out.println(share);
    }

    private static int fun(int m, int p) {
        share = m + p;

        return m - p;
    }
}
```

코드를 보면 share 변수에 static 키워드가 있다. 그래서 share 변수는 스태틱 영역에 변수 공간이 할당된다. 지역 변수와 전역 변수의 각각의 특징은 다음과 같다.

```
스택 프레임에 종속적인 지역 변수
스택 프레임에 독립적인 전역 변수
```

프로젝트 규모에 따라 코드가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 때문에 전역 변수 사용은 가급적 쓰지 않는 것이 좋다.

### 멀티 스레드/ 멀티 프로세스의 이해
`멀티 스레드(Multi Thread)`의 T 메모리 모델은 스택 영역을 **스레드 개수**만큼 분할해서 쓰는 것이다. `멀티 프로세스(Multi Process)`는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조이다. 

`멀티 프로세스`는 각 프로세스마다 각자의 T 메모리가 있고 각자 고유의 공간이므로 서로 참조할 수 없다. 그에 반해 `멀티 스레드`는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조다. `멀티 프로세스`는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 메모리 안전한 구조이지만 메모리 사용량은 그만큼 크다. `멀티 스레드`는 하나의 T 메모리 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만 스태틱 영역과 힙 영역은 공유해서 사용하는 구조다. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조다.

## Reference
[스프링 입문을 위한 자바 객체 지향의 원리와 이해](http://www.yes24.com/Product/Goods/17350624)