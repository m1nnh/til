## 객체지향 프로그래밍

보통 객체지향 프로그래밍을 `OOP`라고 많이 부른다. Object-Oriented Programming의 약자로서 객체의 관점에서 프로그래밍하는 것을 의미한다.

### 절차적/구조적 프로그래밍 

절차적 프로그래밍을 한마디로 표현하자면 `goto`를 쓰지 말라는 것이다. goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문에 goto를 사용하지 못하게 한 것이다.

구조적 프로그래밍은 함수를 쓰라는 의미이다. 함수를 쓰면 좋은 이유는 우선 **중복 코드**를 한 곳에 모아서 관리할 수 있고, **논리를 함수 단위로 분리**해서 **이해하기 쉬운 코드** 즉 클린 코드를 작성할 수 있기 때문에다. 여기에 더해 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 **지역 변수**를 쓰라는 것도 있다.

### 캡! 상추다 

객체지향의 4대 특성인 캡상추다를 보자.

- 캡슐화 (Encapsulation) : 정보 은닉 (Information Hiding)
- 상속 (Inheritance) : 재사용
- 추상화 (Abstraction) : 모델링 
- 다형성 (Polymorphism) : 사용 편의 

### 추상화 (Abstraction)

전산 분야에서 추상화는 영어로 `Abstraction`이다. 추상화는 **공통 특성/공통 속성 추출**이다.

- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 펭귄 : 뽀로로 
- 클래스 설계에서 추상화가 사용된다.
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스이다.

```
class 객체_참조_변수 = new class();
```

### 캡슐화 (Encapsulation)

낮은 결합도를 유지할 수 있도록 설계하는 것이다. 쉽게 말하면, 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화시키는 것을 말한다. 결합도가 낮도록 만들어야 하는 이유는 무엇일까? 결합도란, 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다. 즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다. 그렇다면, 캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까? 바로 **정보 은닉**을 활용한다. 외부에서 접근할 필요가 없는 것들은 `private`로 접근하지 못하도록 제한을 두는 것이다.

### 상속 (Inheritance)

상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다. 이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.

<center><img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjM4g1%2FbtqS1Wd8Vo4%2Fw28pgCB2Gb4Mms2TdhXnyK%2Fimg.png"></center>

자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에, `Child` 클래스는 `Parent` 클래스의 멤버들을 포함한다고 할 수 있다. 클래스는 멤버들의 집합이므로 클래스 Parent와 Child의 관계를 위의 사진과 같이 표현할 수 있다. 그래서 Child 클래스에 새로운 코드가 추가되어도 조상인 Parent 클래스는 아무런 영향도 받지 않는다. 여기서도 알 수 있는 것처럼, 조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다.

- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
- 접근 제어자가 private 또는 default인 멤버들은 상속되지 않는다기보다 상속은 받지만 자손 클래스로부터의 접근이 제한된다.

### 다형성 (Polymorphism)

객체지향 개념에서 다형성이란 여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 이를 좀 더 구체적으로 말하자면, 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

```
class Tv {
    boolean power; // 전원상태
    int channel; // 채널

    void power() { 
        power = !power;
        }

    void channelUp() {
        ++channel;
    }

    void channelDown() {
        --channel;
    }
}

class CaptionTv extends Tv {
    String text; // 캡션을 보여 주기 위한 문자열
    void caption() {
        ...
    }
}
```

```
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

위의 코드에서 CaptionTv 인스턴스 2개를 생성하고, 참조 변수 c와 t가 생성된 인스턴스를 하나씩 참조하도록 하였다. 이 경우 실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조 변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다. Tv 타입의 참조 변수로는 CaptionTv 인스턴스 중에서 Tv 클래스의 멤버들만 사용할 수 있다. 즉, 둘 다 같은 타입의 인스턴스지만 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

### 객체 지향 설계 과정 

- 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
- 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
- 그 데이터를 이용하는 기능을 넣는다.
- 기능은 최대한 캡슐화하여 구현한다.
- 객체 간에 어떻게 메소드 요청을 주고받을 지 결정한다.

### 객체 지향 설계 원칙

`SOLID`라고 부르는 5가지 설계 원칙이 존재한다.

- SRP(Single Responsibility Principle) - 단일 책임 원칙
    - 하나의 클래스는 하나의 책임만 가져야 한다.
- OCP(Open/Closed Principle) - 개방/폐쇄 원칙
    - 클래스는 확장에 대하여 열려 있어야 하고, 변경에 대해서는 닫혀 있어야 한다.
    - 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
- LSP(Liskov Substitution Principle) - 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    - 상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.
- ISP(Interface Segregation Principle) - 인터페이스 분리 원칙
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    - 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.
- DIP(Dependency Inversion Principle) - 의존 역전 원칙 
    - 추상화 된 것은 구체적인 것에 의존하면 안된다. (자주 변경되는 구체적인 것에 의존하지 말고 추상화된 것을 참조)
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
    - 즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.
